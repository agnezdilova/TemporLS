/*
 * generated by Xtext 2.30.0
 */
package su.nsk.iae.tempor.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import su.nsk.iae.tempor.tempor.Model
import org.eclipse.xtext.nodemodel.INode
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.nodemodel.impl.CompositeNode
import org.eclipse.emf.ecore.util.EcoreUtil
import su.nsk.iae.tempor.generator.ExpressionProcessor

@ExtendWith(InjectionExtension)
@InjectWith(TemporInjectorProvider)
class TemporParsingTest {
	@Inject
	ParseHelper<Model> parseHelper
	
	@Test
	def void loadModel() {
		val result = parseHelper.parse('''
			VAR_INPUT
			H : INT;
			D : INT;
			END_VAR
			
			VAR_OUTPUT
			OUT : INT;
			END_VAR
			
			SENTENCE trigger 
			"dryer is on and hands are present" = D AND FE(H)
			END_SENTENCE
			
			SENTENCE inv
			"dryer is on" = D
			END_SENTENCE
			
			SENTENCE rel
			"no hands are present" = H
			END_SENTENCE
			
			SENTENCE rea
			"dryer is on" = NOT D
			END_SENTENCE
			
			SENTENCE fin
			"1 second" = TAU(#T1s)
			END_SENTENCE
			
			REQUIREMENT r_1
			After "dryer is on and hands are present", "dryer is on" should remain valid until either "no hands are present" or 
			reaction is "dryer is on", which must occur immediately after "1 second".
			END_REQUIREMENT
		''')
		EcoreUtil.resolveAll(result);
		Assertions.assertNotNull(result)
		val String res = ExpressionProcessor.ExprToString(result.getSentDeclaration().get(0).getSentenceDeclaration())
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
}
