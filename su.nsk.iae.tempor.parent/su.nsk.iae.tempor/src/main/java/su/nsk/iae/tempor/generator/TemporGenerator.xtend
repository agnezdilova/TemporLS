/*
 * generated by Xtext 2.30.0
 */
package su.nsk.iae.tempor.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import su.nsk.iae.tempor.tempor.Model
import su.nsk.iae.tempor.tempor.Requirement
import su.nsk.iae.tempor.tempor.Trig
import su.nsk.iae.tempor.tempor.Inv
import su.nsk.iae.tempor.tempor.DelFin
import su.nsk.iae.tempor.tempor.RelRea
import su.nsk.iae.tempor.tempor.Rel
import su.nsk.iae.tempor.tempor.Rea
import su.nsk.iae.tempor.tempor.Inv_always
import su.nsk.iae.tempor.tempor.SentenceDeclaration

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TemporGenerator extends AbstractGenerator implements ITemporGenerator{

	Model cnlModel;
	
	int counter;
	
	static def void initGenerators() {
//		val configuration = Platform.extensionRegistry.getConfigurationElementsFor(EXTENSION_ID)
//		for (el : configuration) {
//			val obj = el.createExecutableExtension("class")
//			if (obj instanceof ICnlGenerator) {
//				generators.add(obj)
//			}
//		}
	}
	
	override void setModel(Model model){
		counter=1;
		cnlModel = model;
	}

	override void beforeGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context){
		val model = resource.allContents.
							toIterable.
							filter(Model).
							get(0)
		setModel(model)
	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.allContents.toIterable.filter(Model).get(0)
		
		beforeGenerate(resource, fsa, context)
		val String[] path = resource.getURI().path().split("/");
		val String[] fullFileName = path.get(path.size-1).split("\\.");
		val String fileName = fullFileName.get(0);
		System.out.println(fullFileName)
		//System.out.println(fileName)
		val Output o = generateRequirements()
		fsa.generateFile(fileName+"LtlRequirements.txt",o.getLtl())
		fsa.generateFile(fileName+"EDTLRequirements.csv",o.getEDTLcsv())
		
	}
	
	override Output generateRequirements(){
		var Output o = new Output();
		for (req : cnlModel.getReqDeclaration()){
			val edtl = generateRequirement(req.getRequirement());
			o.addEDTLtuple(edtl,counter,req.getName());
			counter++;
			o.addLtl(EDTLUtils.EDTLtupleToLTL(edtl),req.getName())
		}
		return o
	}
	
	def EDTLtuple generateRequirement(Requirement req){
		var t = new EDTLtuple();
		if (req.getTrigger()!==null){
			t = generate(t,req.getTrigger())
		}else{
			t = generate(t,req.getInvariant()) 
		}
		if(t.getRelease().equals("True")){
			t.setRelease("False")
		}
		return t;
	}
	
	def EDTLtuple generate(EDTLtuple t, Trig trig){
		if (trig.getName()!==null){
			t.setTrigger(sentanceToString(trig.getName()))
		}else{
			t.setTrigger(null)
		}
		var EDTLtuple res = t;
		if (trig.getInvariant()!==null){
			res = generate(t,trig.getInvariant())
		} else if (trig.getRelease_reaction()!==null){
			res = generate(t,trig.getRelease_reaction())
		} else if (trig.getDelay_final()!==null){
			res = generate(t,trig.getDelay_final())
		}else{
			throw new Exception("Trig without branches")
		}
		return res
	}
	
	def EDTLtuple generate(EDTLtuple t, Inv inv){
		t.setInvariant(sentanceToString(inv.getInv()))
		var EDTLtuple res = t;
		if (inv.getRelease_reaction()!==null){
			res = generate(t,inv.getRelease_reaction())
			if (res.getReaction().equals("True")){
				res.setReaction("False")
			}
			
		}else if (inv.getDelay_final()!==null){
			res = generate(t,inv.getDelay_final())
			res.setReaction("True")
		}
		return res
	}
	
	def EDTLtuple generate(EDTLtuple t, DelFin delFin){
		if (delFin.getFin()!==null){
			t.setFinale(sentanceToString(delFin.getFin()));
		}		
		if (delFin.getDelay()!==null){
			t.setDelay(sentanceToString(delFin.getDelay().getDel()))
		} else{
			if(delFin.isImm()){
				t.setDelay("True")
			}else{
				t.setDelay("False")
			}
		}
		
		return t
	}
	
	def EDTLtuple generate(EDTLtuple t, RelRea relRea){
		if (relRea instanceof Rel){
			val rel = relRea as Rel;
			t.setRelease(sentanceToString(rel.getRel()))
			t.setDelay("False")
			if (rel.getReaction()!==null){
				t.setReaction(sentanceToString(rel.getReaction().getRea()))
				if (rel.getDelay_final()!==null){
					return generate(t,rel.getDelay_final())
				}
			}
		}else{
			val rea = relRea as Rea;
			t.setReaction(sentanceToString(rea.getReaction().getRea()))
			t.setDelay("False")
			if (rea.getDelay_final()!==null){
				return generate(t,rea.getDelay_final())
			}
		}
		
		return t
	}
	
	def EDTLtuple generate(EDTLtuple t, Inv_always invAlw){
		t.setInvariant(sentanceToString(invAlw.getInv()))
		t.setTrigger("True")
		if (t.getReaction().equals("True")){
			t.setReaction("False")
		}
		var res = generate(t,invAlw.getRelease_reaction())
		return res
	}
	
	def String sentanceToString(SentenceDeclaration sent){
		return ExpressionProcessor.ExprToString(sent);
	}

}
