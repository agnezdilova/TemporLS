/**
 * generated by Xtext 2.30.0
 */
package su.nsk.iae.tempor.generator;

import com.google.common.collect.Iterables;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import su.nsk.iae.tempor.tempor.DelFin;
import su.nsk.iae.tempor.tempor.Delay;
import su.nsk.iae.tempor.tempor.Inv;
import su.nsk.iae.tempor.tempor.Inv_always;
import su.nsk.iae.tempor.tempor.Model;
import su.nsk.iae.tempor.tempor.Rea;
import su.nsk.iae.tempor.tempor.Rel;
import su.nsk.iae.tempor.tempor.RelRea;
import su.nsk.iae.tempor.tempor.ReqDeclaration;
import su.nsk.iae.tempor.tempor.Requirement;
import su.nsk.iae.tempor.tempor.SentenceDeclaration;
import su.nsk.iae.tempor.tempor.Trig;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class TemporGenerator extends AbstractGenerator implements ITemporGenerator {
  private Model cnlModel;

  private int counter;

  public static void initGenerators() {
  }

  @Override
  public void setModel(final Model model) {
    this.counter = 1;
    this.cnlModel = model;
  }

  @Override
  public void beforeGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Model model = ((Model[])Conversions.unwrapArray((Iterables.<Model>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), Model.class)), Model.class))[0];
    this.setModel(model);
  }

  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    final Model model = ((Model[])Conversions.unwrapArray((Iterables.<Model>filter(IteratorExtensions.<EObject>toIterable(resource.getAllContents()), Model.class)), Model.class))[0];
    this.beforeGenerate(resource, fsa, context);
    final String[] path = resource.getURI().path().split("/");
    int _size = ((List<String>)Conversions.doWrapArray(path)).size();
    int _minus = (_size - 1);
    final String[] fullFileName = (path[_minus]).split("\\.");
    final String fileName = fullFileName[0];
    System.out.println(fullFileName);
    final Output o = this.generateRequirements();
    fsa.generateFile((fileName + "LtlRequirements.txt"), o.getLtl());
    fsa.generateFile((fileName + "EDTLRequirements.csv"), o.getEDTLcsv());
  }

  @Override
  public Output generateRequirements() {
    Output o = new Output();
    EList<ReqDeclaration> _reqDeclaration = this.cnlModel.getReqDeclaration();
    for (final ReqDeclaration req : _reqDeclaration) {
      {
        final EDTLtuple edtl = this.generateRequirement(req.getRequirement());
        o.addEDTLtuple(edtl, this.counter, req.getName());
        this.counter++;
        o.addLtl(EDTLUtils.EDTLtupleToLTL(edtl), req.getName());
      }
    }
    return o;
  }

  public EDTLtuple generateRequirement(final Requirement req) {
    EDTLtuple t = new EDTLtuple();
    Trig _trigger = req.getTrigger();
    boolean _tripleNotEquals = (_trigger != null);
    if (_tripleNotEquals) {
      t = this.generate(t, req.getTrigger());
    } else {
      t = this.generate(t, req.getInvariant());
    }
    boolean _equals = t.getRelease().equals("True");
    if (_equals) {
      t.setRelease("False");
    }
    return t;
  }

  public EDTLtuple generate(final EDTLtuple t, final Trig trig) {
    try {
      SentenceDeclaration _name = trig.getName();
      boolean _tripleNotEquals = (_name != null);
      if (_tripleNotEquals) {
        t.setTrigger(this.sentanceToString(trig.getName()));
      } else {
        t.setTrigger(null);
      }
      EDTLtuple res = t;
      Inv _invariant = trig.getInvariant();
      boolean _tripleNotEquals_1 = (_invariant != null);
      if (_tripleNotEquals_1) {
        res = this.generate(t, trig.getInvariant());
      } else {
        RelRea _release_reaction = trig.getRelease_reaction();
        boolean _tripleNotEquals_2 = (_release_reaction != null);
        if (_tripleNotEquals_2) {
          res = this.generate(t, trig.getRelease_reaction());
        } else {
          DelFin _delay_final = trig.getDelay_final();
          boolean _tripleNotEquals_3 = (_delay_final != null);
          if (_tripleNotEquals_3) {
            res = this.generate(t, trig.getDelay_final());
          } else {
            throw new Exception("Trig without branches");
          }
        }
      }
      return res;
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  public EDTLtuple generate(final EDTLtuple t, final Inv inv) {
    t.setInvariant(this.sentanceToString(inv.getInv()));
    EDTLtuple res = t;
    RelRea _release_reaction = inv.getRelease_reaction();
    boolean _tripleNotEquals = (_release_reaction != null);
    if (_tripleNotEquals) {
      res = this.generate(t, inv.getRelease_reaction());
      boolean _equals = res.getReaction().equals("True");
      if (_equals) {
        res.setReaction("False");
      }
    } else {
      DelFin _delay_final = inv.getDelay_final();
      boolean _tripleNotEquals_1 = (_delay_final != null);
      if (_tripleNotEquals_1) {
        res = this.generate(t, inv.getDelay_final());
        res.setReaction("True");
      }
    }
    return res;
  }

  public EDTLtuple generate(final EDTLtuple t, final DelFin delFin) {
    SentenceDeclaration _fin = delFin.getFin();
    boolean _tripleNotEquals = (_fin != null);
    if (_tripleNotEquals) {
      t.setFinale(this.sentanceToString(delFin.getFin()));
    }
    Delay _delay = delFin.getDelay();
    boolean _tripleNotEquals_1 = (_delay != null);
    if (_tripleNotEquals_1) {
      t.setDelay(this.sentanceToString(delFin.getDelay().getDel()));
    } else {
      boolean _isImm = delFin.isImm();
      if (_isImm) {
        t.setDelay("True");
      } else {
        t.setDelay("False");
      }
    }
    return t;
  }

  public EDTLtuple generate(final EDTLtuple t, final RelRea relRea) {
    if ((relRea instanceof Rel)) {
      final Rel rel = ((Rel) relRea);
      t.setRelease(this.sentanceToString(rel.getRel()));
      t.setDelay("False");
      Rea _reaction = rel.getReaction();
      boolean _tripleNotEquals = (_reaction != null);
      if (_tripleNotEquals) {
        t.setReaction(this.sentanceToString(rel.getReaction().getRea()));
        DelFin _delay_final = rel.getDelay_final();
        boolean _tripleNotEquals_1 = (_delay_final != null);
        if (_tripleNotEquals_1) {
          return this.generate(t, rel.getDelay_final());
        }
      }
    } else {
      final Rea rea = ((Rea) relRea);
      t.setReaction(this.sentanceToString(rea.getReaction().getRea()));
      t.setDelay("False");
      DelFin _delay_final_1 = rea.getDelay_final();
      boolean _tripleNotEquals_2 = (_delay_final_1 != null);
      if (_tripleNotEquals_2) {
        return this.generate(t, rea.getDelay_final());
      }
    }
    return t;
  }

  public EDTLtuple generate(final EDTLtuple t, final Inv_always invAlw) {
    t.setInvariant(this.sentanceToString(invAlw.getInv()));
    t.setTrigger("True");
    boolean _equals = t.getReaction().equals("True");
    if (_equals) {
      t.setReaction("False");
    }
    EDTLtuple res = this.generate(t, invAlw.getRelease_reaction());
    return res;
  }

  public String sentanceToString(final SentenceDeclaration sent) {
    return ExpressionProcessor.ExprToString(sent);
  }
}
